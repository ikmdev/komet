/*
 * Copyright © 2015 Integrated Knowledge Management (support@ikm.dev)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * <h2>Navigation Coordinate System</h2>
 *
 * <p>Provides coordinates that specify how to construct and traverse navigational directed graphs
 * (digraphs) over the knowledge base. Navigation coordinates integrate multiple organizing
 * representations—including inferred taxonomies, stated hierarchies, and custom associations—into
 * unified navigational views suitable for browsing, searching, and analysis.</p>
 *
 * <h3>Core Concept: Directed Graphs</h3>
 *
 * <p>In graph theory, a <strong>directed graph (digraph)</strong> consists of vertices (nodes)
 * connected by edges that have direction. In Tinkar:</p>
 *
 * <ul>
 * <li><strong>Vertices</strong> represent concepts and other entities</li>
 * <li><strong>Edges</strong> represent relationships like is-a, part-of, or custom associations</li>
 * <li><strong>Direction</strong> flows from child to parent (e.g., "Pneumonia" → "Lung disease")</li>
 * <li><strong>Multiple Patterns</strong> can be combined in a single navigational view</li>
 * </ul>
 *
 * <h3>Core Responsibilities</h3>
 *
 * <p>Navigation coordinates specify four key aspects of graph construction and traversal:</p>
 *
 * <dl>
 * <dt><strong>Navigation Patterns</strong></dt>
 * <dd>A set of pattern identifiers specifying which navigation digraphs to use. Common patterns include:
 * <ul>
 *   <li><strong>Inferred Navigation</strong> - Taxonomic hierarchies generated by description logic
 *   classification, based on inferred subsumption relationships</li>
 *   <li><strong>Stated Navigation</strong> - Hierarchies based on explicitly asserted is-a relationships</li>
 *   <li><strong>Custom Patterns</strong> - Domain-specific navigational structures like part-of hierarchies,
 *   procedure-site relationships, or drug-ingredient associations</li>
 * </ul>
 * Multiple patterns can be combined, and their edges are merged into a single navigational graph.
 * </dd>
 *
 * <dt><strong>Vertex State Filtering</strong></dt>
 * <dd>Specifies which vertex states (active/inactive) should be included in the navigational graph.
 * Uses {@link dev.ikm.tinkar.coordinate.stamp.StateSet} to control:
 * <ul>
 *   <li><strong>ACTIVE</strong> - Include only active concepts</li>
 *   <li><strong>INACTIVE</strong> - Include only inactive concepts</li>
 *   <li><strong>ACTIVE_AND_INACTIVE</strong> - Include both</li>
 * </ul>
 * Useful for filtering deprecated or retired concepts from navigation views.
 * </dd>
 *
 * <dt><strong>Vertex Sorting</strong></dt>
 * <dd>Controls whether and how vertices (children of a parent) are sorted. When enabled:
 * <ol>
 *   <li>First, vertices are sorted by custom sort patterns (if specified)</li>
 *   <li>Then, by the natural alphabetical order of concept descriptions</li>
 * </ol>
 * When disabled, vertices appear in arbitrary order (typically discovery order), which is faster
 * but less user-friendly.
 * </dd>
 *
 * <dt><strong>Vertex Sort Patterns</strong></dt>
 * <dd>Optional priority list of patterns used for custom vertex ordering. For example, a medical
 * terminology might use a "severity" pattern to sort diseases by severity before alphabetical order.
 * If empty and sorting is enabled, only natural alphabetical order is used.
 * </dd>
 * </dl>
 *
 * <h3>Navigation Graph Construction</h3>
 *
 * <p>Navigation graphs are constructed by:</p>
 * <ol>
 * <li><strong>Pattern Collection</strong> - Gather all navigation patterns specified in the coordinate</li>
 * <li><strong>Edge Extraction</strong> - Extract parent-child edges from each pattern</li>
 * <li><strong>Edge Merging</strong> - Combine edges from all patterns into single graph</li>
 * <li><strong>Vertex Filtering</strong> - Remove vertices not matching state criteria</li>
 * <li><strong>Vertex Sorting</strong> - Sort children according to sort specifications</li>
 * </ol>
 *
 * <h3>Core Interface</h3>
 *
 * <p>The {@link dev.ikm.tinkar.coordinate.navigation.NavigationCoordinate} interface defines
 * the contract for all navigation coordinate implementations. Key features include:</p>
 *
 * <ul>
 * <li>Accessor methods for navigation patterns, vertex states, and sorting preferences</li>
 * <li>Content-based UUID generation for coordinate identity and caching</li>
 * <li>Conversion to {@link dev.ikm.tinkar.coordinate.navigation.NavigationCoordinateRecord}</li>
 * <li>User-friendly string representation for debugging</li>
 * </ul>
 *
 * <h3>Implementation Patterns</h3>
 *
 * <h4>NavigationCoordinateRecord</h4>
 * <p>Immutable record implementation providing thread-safe navigation coordinates. Created via
 * factory methods in the {@code Coordinates.Navigation} class:</p>
 * <pre>{@code
 * // Inferred navigation (taxonomy from classification)
 * NavigationCoordinate inferred = Coordinates.Navigation.inferred();
 *
 * // Stated navigation (author-asserted hierarchy)
 * NavigationCoordinate stated = Coordinates.Navigation.stated();
 *
 * // Custom navigation coordinate
 * NavigationCoordinateRecord custom = NavigationCoordinateRecord.make(
 *     IntIds.set.of(
 *         TinkarTerm.INFERRED_NAVIGATION.nid(),
 *         TinkarTerm.CUSTOM_NAVIGATION.nid()
 *     ),
 *     StateSet.ACTIVE,                    // Only active concepts
 *     IntIds.list.of(                      // Sort patterns
 *         TinkarTerm.SEVERITY_PATTERN.nid(),
 *         TinkarTerm.ALPHABETICAL_PATTERN.nid()
 *     ),
 *     true                                 // Enable sorting
 * );
 * }</pre>
 *
 * <h4>NavigationCoordinateDelegate</h4>
 * <p>Delegation pattern allowing classes to implement NavigationCoordinate by delegating to an
 * underlying instance:</p>
 * <pre>{@code
 * public class ViewCalculator implements NavigationCoordinateDelegate {
 *     private final NavigationCoordinate navigationCoordinate;
 *
 *     @Override
 *     public NavigationCoordinate getNavigationCoordinate() {
 *         return navigationCoordinate;
 *     }
 * }
 * }</pre>
 *
 * <h3>Common Navigation Patterns</h3>
 *
 * <h4>Inferred Navigation</h4>
 * <p>Based on taxonomy generated by description logic classification:</p>
 * <ul>
 * <li>Edges represent inferred subsumption (is-a) relationships</li>
 * <li>Generated automatically by classifiers like Snorocket</li>
 * <li>Includes transitive closure of stated relationships plus inferences</li>
 * <li>Most complete view of conceptual hierarchies</li>
 * <li>Used for semantic queries and subsumption testing</li>
 * </ul>
 *
 * <h4>Stated Navigation</h4>
 * <p>Based on author-asserted relationships:</p>
 * <ul>
 * <li>Edges represent explicitly stated is-a relationships</li>
 * <li>Authored directly by terminology maintainers</li>
 * <li>May be incomplete (not transitively closed)</li>
 * <li>Reflects editorial structure and intent</li>
 * <li>Used for authoring and quality assurance</li>
 * </ul>
 *
 * <h4>Mixed Navigation</h4>
 * <p>Combining multiple patterns:</p>
 * <pre>{@code
 * NavigationCoordinateRecord mixed = NavigationCoordinateRecord.make(
 *     IntIds.set.of(
 *         TinkarTerm.INFERRED_NAVIGATION.nid(),      // Taxonomy
 *         TinkarTerm.PART_OF_NAVIGATION.nid(),       // Part-of hierarchy
 *         TinkarTerm.PROCEDURE_SITE_NAVIGATION.nid() // Procedure sites
 *     ),
 *     StateSet.ACTIVE,
 *     IntIds.list.empty(),
 *     true
 * );
 * // Creates unified graph with edges from all three patterns
 * }</pre>
 *
 * <h3>Vertex Sorting Behavior</h3>
 *
 * <p>When {@code sortVertices()} returns {@code true}, children are sorted in stages:</p>
 *
 * <ol>
 * <li><strong>Sort Pattern Priority</strong> - For each pattern in {@code verticesSortPatternNidList()}
 * (in order), apply pattern-specific sorting</li>
 * <li><strong>Natural Order</strong> - Finally, sort by alphabetical order of concept descriptions
 * as determined by the language coordinate</li>
 * </ol>
 *
 * <p>When {@code sortVertices()} returns {@code false}, children appear in discovery order
 * (typically insertion order), providing better performance at the cost of user experience.</p>
 *
 * <h3>Integration with Calculators</h3>
 *
 * <p>Navigation coordinates are used by {@link dev.ikm.tinkar.coordinate.navigation.calculator.NavigationCalculator}
 * implementations to construct and traverse navigational graphs. The calculator package provides
 * the actual graph operations:</p>
 *
 * <pre>{@code
 * NavigationCalculator navCalc = NavigationCalculatorWithCache.getCalculator(
 *     stampCoord,
 *     navigationCoord
 * );
 *
 * // Get parents of a concept
 * IntIdSet parents = navCalc.parentsOf(conceptNid);
 *
 * // Get children of a concept (sorted if coordinate specifies)
 * IntIdSet children = navCalc.childrenOf(conceptNid);
 *
 * // Get all ancestors (transitive closure of parents)
 * IntIdSet ancestors = navCalc.ancestorsOf(conceptNid);
 *
 * // Test subsumption
 * boolean isAncestor = navCalc.isDescendentOf(childNid, parentNid);
 * }</pre>
 *
 * <h3>State Filtering Examples</h3>
 *
 * <pre>{@code
 * // Show only active concepts in navigation
 * NavigationCoordinateRecord activeOnly = NavigationCoordinateRecord.makeInferred()
 *     .withVertexStates(StateSet.ACTIVE);
 *
 * // Show both active and inactive (useful for administrative views)
 * NavigationCoordinateRecord all = NavigationCoordinateRecord.makeInferred()
 *     .withVertexStates(StateSet.ACTIVE_AND_INACTIVE);
 *
 * // Show only inactive concepts (useful for retirement analysis)
 * NavigationCoordinateRecord inactiveOnly = NavigationCoordinateRecord.makeInferred()
 *     .withVertexStates(StateSet.INACTIVE);
 * }</pre>
 *
 * <h3>Performance Considerations</h3>
 *
 * <ul>
 * <li><strong>Sorting Overhead</strong> - Enabling vertex sorting adds computational cost,
 * especially with many children. Consider disabling for performance-critical paths.</li>
 * <li><strong>Pattern Complexity</strong> - More patterns mean more edges to merge. Keep
 * pattern sets focused for better performance.</li>
 * <li><strong>Caching</strong> - Navigation calculators cache graph structures based on
 * coordinate UUIDs for efficient reuse.</li>
 * <li><strong>State Filtering</strong> - Filtering by state is efficient and should not
 * significantly impact performance.</li>
 * </ul>
 *
 * <h3>Thread Safety and Immutability</h3>
 *
 * <p>NavigationCoordinateRecord instances are immutable and thread-safe, suitable for:</p>
 * <ul>
 * <li>Concurrent graph traversal operations</li>
 * <li>Caching in calculator implementations</li>
 * <li>Use as map keys for graph caches</li>
 * <li>Sharing across service boundaries</li>
 * </ul>
 *
 * @see dev.ikm.tinkar.coordinate.navigation.NavigationCoordinate
 * @see dev.ikm.tinkar.coordinate.navigation.NavigationCoordinateRecord
 * @see dev.ikm.tinkar.coordinate.navigation.NavigationCoordinateDelegate
 * @see dev.ikm.tinkar.coordinate.navigation.calculator
 * @see dev.ikm.tinkar.coordinate.stamp.StateSet
 * @see dev.ikm.tinkar.coordinate.Coordinates.Navigation
 */
package dev.ikm.tinkar.coordinate.navigation;
