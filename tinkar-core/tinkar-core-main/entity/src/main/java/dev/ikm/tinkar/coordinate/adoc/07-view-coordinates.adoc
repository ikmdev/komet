= View Coordinates

[NOTE]
====
This document describes the IKE Coordinate System (Integrated Knowledge Ecosystem), based on the HL7 TINKAR specification. Technical references use "Tinkar" in code for backward compatibility.
====

== Overview

View coordinates unify all five coordinate types into a single, cohesive specification. Instead of managing STAMP, Language, Logic, Navigation, and Edit coordinates separately, a view coordinate provides:

* **Unified Access** - Single point of configuration for all coordinate types
* **Simplified API** - One calculator that delegates to specialized calculators
* **Consistent Context** - All operations use the same coordinated view
* **Easy Switching** - Change entire context by switching view coordinates

[source,java]
----
public interface ViewCoordinate {
    StampCoordinate stampCoordinate();
    List<LanguageCoordinate> languageCoordinateList();
    LogicCoordinate logicCoordinate();
    NavigationCoordinate navigationCoordinate();
    EditCoordinate editCoordinate();
}
----

== The View Calculator

The ViewCalculator provides unified access to all coordinate operations:

[source,mermaid]
----
graph TD
    A[ViewCalculator] --> B[StampCalculator]
    A --> C[LanguageCalculator]
    A --> D[LogicCalculator]
    A --> E[NavigationCalculator]
    A --> F[EditCoordinate]

    B --> G[Version Selection]
    C --> H[Description Selection]
    D --> I[Axiom Retrieval]
    E --> J[Graph Traversal]
    F --> K[Change Attribution]

    style A fill:#e1f5ff,stroke:#0066cc,stroke-width:3px
    style B fill:#fff4e6,stroke:#ff9800
    style C fill:#f3e5f5,stroke:#9c27b0
    style D fill:#e8f5e9,stroke:#4caf50
    style E fill:#fff3e0,stroke:#ff9800
    style F fill:#fce4ec,stroke:#e91e63
----

== Creating View Coordinates

=== Using Predefined Views

[source,java]
----
// Default development view
ViewCoordinateRecord view = Coordinates.View.DefaultView();

// What this includes:
// - STAMP: Development path, latest, active only
// - Language: English (US), regular name, FSN fallback
// - Logic: EL++ profile, stated axioms
// - Navigation: Inferred hierarchy, active only, sorted
// - Edit: User as author, SOLOR overlay module

// Get calculator
ViewCalculator calculator = ViewCalculatorWithCache.getCalculator(view);

// Use for all operations
String description = calculator.getDescriptionText(conceptNid);
Latest<ConceptVersion> latest = calculator.latest(conceptNid);
int[] parents = calculator.unsortedParentsOf(conceptNid);
----

=== Custom View Creation

[source,java]
----
// Create custom view for specific needs
ViewCoordinateRecord customView = ViewCoordinateRecord.make(
    // STAMP: Production path, point-in-time
    StampCoordinateRecord.make(
        StateSet.ACTIVE_ONLY,
        StampPositionRecord.make(
            releaseTimestamp,
            TinkarTerm.MASTER_PATH.nid()
        )
    ),

    // Language: Spanish with English fallback
    List.of(
        LanguageCoordinateRecord.make(
            TinkarTerm.SPANISH_LANGUAGE.nid(),
            TinkarTerm.SPANISH_DIALECT_ASSEMBLAGE.nid()
        ),
        LanguageCoordinateRecord.make(
            TinkarTerm.ENGLISH_LANGUAGE.nid(),
            TinkarTerm.US_DIALECT_ASSEMBLAGE.nid()
        )
    ),

    // Logic: EL++ with inferred axioms
    LogicCoordinateRecord.make(
        TinkarTerm.EL_PLUS_PLUS_STATED_AXIOMS_PATTERN.nid(),
        TinkarTerm.EL_PLUS_PLUS_INFERRED_AXIOMS_PATTERN.nid(),
        TinkarTerm.SNOROCKET_CLASSIFIER.nid(),
        TinkarTerm.STATED_PREMISE_TYPE.nid()
    ),

    // Navigation: Stated hierarchy, all states
    NavigationCoordinateRecord.make(
        IntIds.set.of(TinkarTerm.STATED_NAVIGATION.nid()),
        StateSet.ACTIVE_AND_INACTIVE,
        true,
        IntIds.list.empty()
    ),

    // Edit: Specific user and module
    EditCoordinateRecord.make(
        userNid,
        moduleNid,
        moduleNid,
        TinkarTerm.DEVELOPMENT_PATH.nid(),
        TinkarTerm.MASTER_PATH.nid()
    )
);
----

== Common View Patterns

=== Pattern 1: Development View

For active development work:

[source,java]
----
public ViewCoordinateRecord createDevelopmentView(int authorNid, int moduleNid) {
    return ViewCoordinateRecord.make(
        // Latest on development path
        Coordinates.Stamp.DevelopmentLatestActiveOnly(),

        // English descriptions
        Coordinates.Language.UsEnglishRegularName(),

        // Stated axioms for editing
        Coordinates.Logic.ElPlusPlus(),

        // Inferred navigation for browsing
        Coordinates.Navigation.inferred(),

        // User-specific edit coordinate
        EditCoordinateRecord.make(
            authorNid,
            moduleNid,
            moduleNid,
            TinkarTerm.DEVELOPMENT_PATH.nid(),
            TinkarTerm.DEVELOPMENT_PATH.nid()
        )
    );
}
----

=== Pattern 2: Production View

For production/release access:

[source,java]
----
public ViewCoordinateRecord createProductionView(long releaseTime) {
    return ViewCoordinateRecord.make(
        // Fixed point in time on master path
        StampCoordinateRecord.make(
            StateSet.ACTIVE_ONLY,
            StampPositionRecord.make(releaseTime, TinkarTerm.MASTER_PATH.nid())
        ),

        // English descriptions
        Coordinates.Language.UsEnglishRegularName(),

        // Inferred axioms for querying
        LogicCoordinateRecord.make(
            TinkarTerm.EL_PLUS_PLUS_STATED_AXIOMS_PATTERN.nid(),
            TinkarTerm.EL_PLUS_PLUS_INFERRED_AXIOMS_PATTERN.nid(),
            TinkarTerm.SNOROCKET_CLASSIFIER.nid(),
            TinkarTerm.INFERRED_PREMISE_TYPE.nid()
        ),

        // Inferred navigation
        Coordinates.Navigation.inferred(),

        // Read-only (edit coordinate not used)
        Coordinates.Edit.Default()
    );
}
----

=== Pattern 3: Administrative View

For maintenance and content review:

[source,java]
----
public ViewCoordinateRecord createAdminView() {
    return ViewCoordinateRecord.make(
        // All states, latest on development
        StampCoordinateRecord.make(
            StateSet.ACTIVE_AND_INACTIVE,  // See inactive content
            StampPositionRecord.make(
                Long.MAX_VALUE,
                TinkarTerm.DEVELOPMENT_PATH.nid()
            )
        ),

        // English descriptions
        Coordinates.Language.UsEnglishRegularName(),

        // Both stated and inferred
        Coordinates.Logic.ElPlusPlus(),

        // Navigation with inactive vertices
        NavigationCoordinateRecord.make(
            IntIds.set.of(TinkarTerm.INFERRED_NAVIGATION.nid()),
            StateSet.ACTIVE_AND_INACTIVE,  // See inactive in hierarchy
            true,
            IntIds.list.empty()
        ),

        // Admin user edit coordinate
        EditCoordinateRecord.make(
            TinkarTerm.USER.nid(),
            TinkarTerm.SOLOR_OVERLAY_MODULE.nid(),
            TinkarTerm.SOLOR_OVERLAY_MODULE.nid(),
            TinkarTerm.DEVELOPMENT_PATH.nid(),
            TinkarTerm.MASTER_PATH.nid()
        )
    );
}
----

=== Pattern 4: Multilingual View

For international applications:

[source,java]
----
public ViewCoordinateRecord createMultilingualView(List<Integer> languageNids) {
    // Create language coordinate list with priorities
    List<LanguageCoordinate> languageCoords = languageNids.stream()
        .map(langNid -> LanguageCoordinateRecord.make(
            langNid,
            getDialectNidForLanguage(langNid)
        ))
        .collect(Collectors.toList());

    return ViewCoordinateRecord.make(
        Coordinates.Stamp.DevelopmentLatestActiveOnly(),
        languageCoords,  // Multiple languages with fallback
        Coordinates.Logic.ElPlusPlus(),
        Coordinates.Navigation.inferred(),
        Coordinates.Edit.Default()
    );
}
----

== Using View Calculators

=== Unified Operations

The ViewCalculator delegates to specialized calculators:

[source,java]
----
ViewCoordinateRecord view = Coordinates.View.DefaultView();
ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);

// STAMP operations (delegates to StampCalculator)
Latest<ConceptVersion> latest = calc.latest(conceptNid);
boolean isLatest = calc.isLatestActive(versionNid);

// Language operations (delegates to LanguageCalculator)
String description = calc.getDescriptionText(conceptNid);
String fullName = calc.getFullyQualifiedDescriptionText(conceptNid);
Optional<String> preferredText = calc.getPreferredDescriptionText(conceptNid);

// Navigation operations (delegates to NavigationCalculator)
int[] parents = calc.unsortedParentsOf(conceptNid);
int[] children = calc.sortedChildrenOf(conceptNid);
IntIdSet ancestors = calc.ancestorsOf(conceptNid);

// Logic operations (delegates to LogicCalculator)
DiTreeEntity statedAxioms = calc.getStatedAxiomTree(conceptNid);
DiTreeEntity inferredAxioms = calc.getInferredAxiomTree(conceptNid);

// Edit operations (direct access)
EditCoordinate editCoord = calc.editCoordinate();
int authorNid = editCoord.getAuthorNidForChanges();
----

=== Switching Contexts

Change view to switch entire context:

[source,java]
----
// Start with development view
ViewCoordinateRecord devView = createDevelopmentView(userNid, moduleNid);
ViewCalculator devCalc = ViewCalculatorWithCache.getCalculator(devView);

// Work in development
String devDescription = devCalc.getDescriptionText(conceptNid);
int[] devParents = devCalc.unsortedParentsOf(conceptNid);

// Switch to production view
ViewCoordinateRecord prodView = createProductionView(releaseTimestamp);
ViewCalculator prodCalc = ViewCalculatorWithCache.getCalculator(prodView);

// Same operations, different results
String prodDescription = prodCalc.getDescriptionText(conceptNid);
int[] prodParents = prodCalc.unsortedParentsOf(conceptNid);

// Descriptions and hierarchies may differ between dev and production
----

== View Coordinate Modification

Create modified views while preserving other coordinates:

[source,java]
----
ViewCoordinateRecord originalView = Coordinates.View.DefaultView();

// Change just the STAMP coordinate
ViewCoordinateRecord timeView = ViewCoordinateRecord.make(
    originalView.stampCoordinate().withStampPosition(
        StampPositionRecord.make(historicTime, pathNid)
    ),
    originalView.languageCoordinateList(),
    originalView.logicCoordinate(),
    originalView.navigationCoordinate(),
    originalView.editCoordinate()
);

// Change just the language coordinates
ViewCoordinateRecord spanishView = ViewCoordinateRecord.make(
    originalView.stampCoordinate(),
    List.of(Coordinates.Language.SpanishLanguage()),
    originalView.logicCoordinate(),
    originalView.navigationCoordinate(),
    originalView.editCoordinate()
);

// Change navigation to stated
ViewCoordinateRecord statedView = ViewCoordinateRecord.make(
    originalView.stampCoordinate(),
    originalView.languageCoordinateList(),
    originalView.logicCoordinate(),
    Coordinates.Navigation.stated(),
    originalView.editCoordinate()
);
----

== Practical Examples

=== Example 1: Comparing Development vs Production

[source,java]
----
public void compareDevVsProd(int conceptNid, long releaseTime) {
    // Development view
    ViewCalculator devCalc = ViewCalculatorWithCache.getCalculator(
        createDevelopmentView(userNid, moduleNid)
    );

    // Production view
    ViewCalculator prodCalc = ViewCalculatorWithCache.getCalculator(
        createProductionView(releaseTime)
    );

    // Compare descriptions
    String devDesc = devCalc.getDescriptionText(conceptNid);
    String prodDesc = prodCalc.getDescriptionText(conceptNid);

    if (!devDesc.equals(prodDesc)) {
        System.out.println("Description changed since release:");
        System.out.println("  Production: " + prodDesc);
        System.out.println("  Development: " + devDesc);
    }

    // Compare hierarchies
    IntIdSet devAncestors = devCalc.ancestorsOf(conceptNid);
    IntIdSet prodAncestors = prodCalc.ancestorsOf(conceptNid);

    IntIdSet addedAncestors = devAncestors.difference(prodAncestors);
    IntIdSet removedAncestors = prodAncestors.difference(devAncestors);

    if (!addedAncestors.isEmpty()) {
        System.out.println("New ancestors in development:");
        addedAncestors.forEach(nid ->
            System.out.println("  " + devCalc.getDescriptionText(nid))
        );
    }
}
----

=== Example 2: User-Specific Views

[source,java]
----
public class ViewManager {
    private final Map<String, ViewCoordinateRecord> userViews = new HashMap<>();

    public ViewCalculator getViewForUser(String userId) {
        ViewCoordinateRecord view = userViews.computeIfAbsent(userId, id -> {
            User user = getUserDetails(id);

            return ViewCoordinateRecord.make(
                // User's preferred time/path
                StampCoordinateRecord.make(
                    user.showInactive() ?
                        StateSet.ACTIVE_AND_INACTIVE :
                        StateSet.ACTIVE_ONLY,
                    StampPositionRecord.make(
                        user.getViewTime(),
                        user.getPathNid()
                    )
                ),

                // User's language preferences
                user.getLanguagePreferences(),

                // Standard logic
                Coordinates.Logic.ElPlusPlus(),

                // User's navigation preference
                user.preferStated() ?
                    Coordinates.Navigation.stated() :
                    Coordinates.Navigation.inferred(),

                // User-specific edit coordinate
                EditCoordinateRecord.make(
                    user.getConceptNid(),
                    user.getDefaultModule(),
                    user.getDefaultModule(),
                    TinkarTerm.DEVELOPMENT_PATH.nid(),
                    TinkarTerm.MASTER_PATH.nid()
                )
            );
        });

        return ViewCalculatorWithCache.getCalculator(view);
    }
}
----

=== Example 3: Temporal Comparison

[source,java]
----
public void analyzeChangesOverTime(int conceptNid, long startTime, long endTime) {
    // View at start time
    ViewCalculator startCalc = ViewCalculatorWithCache.getCalculator(
        ViewCoordinateRecord.make(
            StampCoordinateRecord.make(
                StateSet.ACTIVE_AND_INACTIVE,
                StampPositionRecord.make(startTime, pathNid)
            ),
            Coordinates.Language.UsEnglishRegularName(),
            Coordinates.Logic.ElPlusPlus(),
            Coordinates.Navigation.inferred(),
            Coordinates.Edit.Default()
        )
    );

    // View at end time
    ViewCalculator endCalc = ViewCalculatorWithCache.getCalculator(
        ViewCoordinateRecord.make(
            StampCoordinateRecord.make(
                StateSet.ACTIVE_AND_INACTIVE,
                StampPositionRecord.make(endTime, pathNid)
            ),
            Coordinates.Language.UsEnglishRegularName(),
            Coordinates.Logic.ElPlusPlus(),
            Coordinates.Navigation.inferred(),
            Coordinates.Edit.Default()
        )
    );

    // Compare states
    Latest<ConceptVersion> startVersion = startCalc.latest(conceptNid);
    Latest<ConceptVersion> endVersion = endCalc.latest(conceptNid);

    if (startVersion.isPresent() && endVersion.isPresent()) {
        if (startVersion.get().state() != endVersion.get().state()) {
            System.out.println("State changed: " +
                startVersion.get().state() + " â†’ " +
                endVersion.get().state());
        }
    }

    // Compare descriptions
    String startDesc = startCalc.getDescriptionText(conceptNid);
    String endDesc = endCalc.getDescriptionText(conceptNid);

    if (!startDesc.equals(endDesc)) {
        System.out.println("Description changed:");
        System.out.println("  Before: " + startDesc);
        System.out.println("  After: " + endDesc);
    }
}
----

== Best Practices

=== DO: Use View Coordinates for Consistency

[source,java]
----
// GOOD: Single view for all operations
ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);

String description = calc.getDescriptionText(conceptNid);
int[] parents = calc.unsortedParentsOf(conceptNid);
Latest<ConceptVersion> latest = calc.latest(conceptNid);

// All operations use same coordinated context
----

=== DO: Cache View Calculators

[source,java]
----
// GOOD: Reuse calculator
ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);

for (int conceptNid : conceptNids) {
    String desc = calc.getDescriptionText(conceptNid);
    // ... process
}

// ViewCalculatorWithCache handles caching internally
----

=== DON'T: Mix Coordinate Types

[source,java]
----
// BAD: Mixing different coordinates
StampCalculator stampCalc1 = StampCalculatorWithCache.getCalculator(stamp1);
LanguageCalculator langCalc = LanguageCalculatorWithCache.getCalculator(
    stamp2,  // Different stamp!
    languageCoords
);

// Inconsistent context leads to confusing results
----

=== DO: Create Views for Specific Use Cases

[source,java]
----
// GOOD: Specific views for different needs
public class Views {
    public static ViewCoordinateRecord forDevelopment() { ... }
    public static ViewCoordinateRecord forProduction() { ... }
    public static ViewCoordinateRecord forAudit() { ... }
    public static ViewCoordinateRecord forUser(User user) { ... }
}

// Clear, reusable view definitions
----

== Summary

View coordinates unify the five coordinate types:

* **Unified Access** - Single calculator for all operations
* **Consistent Context** - All operations use coordinated view
* **Easy Switching** - Change context by switching views
* **Delegation** - ViewCalculator delegates to specialized calculators

Key points:

* Use predefined views for common scenarios
* Create custom views for specific needs
* Cache view calculators for performance
* Switch views to change entire context
* Modify views while preserving other coordinates

View coordinates simplify coordinate management by providing a unified, consistent way to access all Tinkar functionality.
