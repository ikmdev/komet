/*
 * Copyright Â© 2015 Integrated Knowledge Management (support@ikm.dev)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * <h2>Logic Coordinate System</h2>
 *
 * <p>Provides coordinates that configure description logic reasoning, axiom processing, and
 * classification within the Tinkar framework. Logic coordinates specify which classifier to use,
 * which description logic profile to apply, and where to find stated and inferred axioms for
 * concepts. These coordinates enable subsumption testing, taxonomy generation, and semantic
 * reasoning over concept definitions.</p>
 *
 * <h3>Core Responsibilities</h3>
 *
 * <p>Logic coordinates specify eight critical components for description logic reasoning:</p>
 *
 * <dl>
 * <dt><strong>Classifier</strong></dt>
 * <dd>Identifies the reasoning engine used for classification and subsumption testing (e.g.,
 * Snorocket, ELK, HermiT). The classifier processes concept axioms according to the description
 * logic profile and generates inferred relationships and taxonomies.</dd>
 *
 * <dt><strong>Description Logic Profile</strong></dt>
 * <dd>Specifies the formal logic expressivity used for reasoning (e.g., EL++, ALC, SROIQ).
 * The profile determines which logical constructors are supported and affects reasoning
 * performance and decidability. EL++ is commonly used in medical terminologies for its balance
 * of expressivity and computational efficiency.</dd>
 *
 * <dt><strong>Stated Axioms Pattern</strong></dt>
 * <dd>Identifies the pattern where stated (asserted) logical definitions are stored as semantic
 * entities. Stated axioms represent the knowledge explicitly asserted by terminology authors,
 * typically stored as description logic expression trees (DiTree) in semantics that reference
 * concepts.</dd>
 *
 * <dt><strong>Inferred Axioms Pattern</strong></dt>
 * <dd>Identifies the pattern where inferred (classified) logical definitions are stored. Inferred
 * axioms are generated by the classifier and represent the complete set of logical consequences
 * derivable from stated axioms. These are typically used for subsumption queries and taxonomy
 * navigation.</dd>
 *
 * <dt><strong>Concept Member Pattern</strong></dt>
 * <dd>Identifies the pattern defining which concepts should be included in classification through
 * semantic entities. This allows selective classification of concept subsets within larger
 * knowledge bases.</dd>
 *
 * <dt><strong>Stated Navigation Pattern</strong></dt>
 * <dd>Identifies the pattern defining the navigational digraph generated from stated axioms.
 * This pattern specifies how stated relationships form hierarchical and associative structures
 * for browsing.</dd>
 *
 * <dt><strong>Inferred Navigation Pattern</strong></dt>
 * <dd>Identifies the pattern defining the navigational digraph generated from classified concepts.
 * This pattern specifies how inferred subsumption relationships form taxonomic hierarchies based
 * on the results of description logic reasoning.</dd>
 *
 * <dt><strong>Root Concept</strong></dt>
 * <dd>Identifies the top-level concept serving as the root of the taxonomy. This is typically
 * a concept like "Root concept" or "Entity" from which all other concepts descend through
 * is-a relationships.</dd>
 * </dl>
 *
 * <h3>Premise Types</h3>
 *
 * <p>The {@link dev.ikm.tinkar.coordinate.logic.PremiseType} enum distinguishes between stated
 * and inferred axioms:</p>
 *
 * <dl>
 * <dt>{@code STATED}</dt>
 * <dd>Axioms explicitly asserted by terminology authors. These represent the base knowledge from
 * which inferences are derived. Stated axioms are typically incomplete but more directly reflect
 * editorial intent.</dd>
 *
 * <dt>{@code INFERRED}</dt>
 * <dd>Axioms generated by the classifier through logical reasoning. These represent the complete
 * set of logical consequences, including transitive closures and implicit subsumption relationships.
 * Inferred axioms are used for queries requiring full logical consistency.</dd>
 * </dl>
 *
 * <h3>Taxonomy Flags</h3>
 *
 * <p>The {@link dev.ikm.tinkar.coordinate.logic.TaxonomyFlag} enum provides metadata about
 * taxonomy relationships and concept status, supporting efficient graph operations and
 * classification status tracking.</p>
 *
 * <h3>Core Interface</h3>
 *
 * <p>The {@link dev.ikm.tinkar.coordinate.logic.LogicCoordinate} interface defines the contract
 * for all logic coordinate implementations. Key features include:</p>
 *
 * <ul>
 * <li>Accessor methods for all eight coordinate components</li>
 * <li>Content-based UUID generation for coordinate identity and caching</li>
 * <li>Axiom retrieval methods for stated and inferred definitions</li>
 * <li>Pattern selection methods for premise types</li>
 * <li>Conversion to {@link dev.ikm.tinkar.coordinate.logic.LogicCoordinateRecord}</li>
 * </ul>
 *
 * <h3>Implementation Patterns</h3>
 *
 * <h4>LogicCoordinateRecord</h4>
 * <p>Immutable record implementation providing thread-safe logic coordinates. Typically created
 * via the {@code Coordinates.Logic} factory class:</p>
 * <pre>{@code
 * // Standard EL++ configuration with Snorocket classifier
 * LogicCoordinateRecord elPlusPlus = Coordinates.Logic.ElPlusPlus();
 *
 * // Custom logic coordinate
 * LogicCoordinateRecord custom = LogicCoordinateRecord.make(
 *     TinkarTerm.SNOROCKET_CLASSIFIER,
 *     TinkarTerm.EL_PLUS_PLUS_PROFILE,
 *     TinkarTerm.EL_PLUS_PLUS_INFERRED_AXIOMS_PATTERN,
 *     TinkarTerm.EL_PLUS_PLUS_STATED_AXIOMS_PATTERN,
 *     TinkarTerm.SOLOR_CONCEPT_ASSEMBLAGE,
 *     TinkarTerm.STATED_NAVIGATION_PATTERN,
 *     TinkarTerm.INFERRED_NAVIGATION_PATTERN,
 *     TinkarTerm.ROOT_VERTEX
 * );
 * }</pre>
 *
 * <h4>LogicCoordinateDelegate</h4>
 * <p>Delegation pattern allowing classes to implement LogicCoordinate by delegating to an
 * underlying instance:</p>
 * <pre>{@code
 * public class ViewCalculator implements LogicCoordinateDelegate {
 *     private final LogicCoordinate logicCoordinate;
 *
 *     @Override
 *     public LogicCoordinate getLogicCoordinate() {
 *         return logicCoordinate;
 *     }
 * }
 * }</pre>
 *
 * <h3>Axiom Retrieval</h3>
 *
 * <p>Logic coordinates provide methods for retrieving axioms with STAMP filtering:</p>
 *
 * <pre>{@code
 * LogicCoordinate logic = Coordinates.Logic.ElPlusPlus();
 * StampCoordinate stamp = Coordinates.Stamp.DevelopmentLatestActiveOnly();
 *
 * // Get stated axioms for a concept
 * Latest<DiTreeEntity> statedAxioms =
 *     logic.getStatedAxiomsVersion(conceptNid, stamp);
 *
 * // Get inferred axioms for a concept
 * Latest<DiTreeEntity> inferredAxioms =
 *     logic.getInferredAxiomsVersion(conceptNid, stamp);
 *
 * // Get axioms for specific premise type
 * Latest<DiTreeEntity> axioms =
 *     logic.getAxiomsVersion(conceptNid, PremiseType.STATED, stamp);
 *
 * // Get complete axiom chronology (all versions)
 * ImmutableList<DiTreeEntity> chronology =
 *     logic.getAxiomsChronology(conceptNid, PremiseType.INFERRED);
 * }</pre>
 *
 * <h3>Pattern Selection</h3>
 *
 * <p>Logic coordinates map premise types to their corresponding patterns:</p>
 *
 * <pre>{@code
 * // Get the pattern for a premise type
 * PatternFacade statedPattern =
 *     logic.getPatternForPremiseType(PremiseType.STATED);
 *
 * PatternFacade inferredPattern =
 *     logic.getPatternForPremiseType(PremiseType.INFERRED);
 *
 * // Direct pattern access
 * PatternFacade statedAxioms = logic.statedAxiomsPattern();
 * PatternFacade inferredAxioms = logic.inferredAxiomsPattern();
 * PatternFacade statedNav = logic.statedNavigationPattern();
 * PatternFacade inferredNav = logic.inferredNavigationPattern();
 * }</pre>
 *
 * <h3>Integration with Classification</h3>
 *
 * <p>Logic coordinates specify the configuration for classification workflows:</p>
 *
 * <ol>
 * <li><strong>Load Stated Axioms</strong> - Retrieve stated axioms from the pattern specified
 * by {@code statedAxiomsPatternNid()}</li>
 *
 * <li><strong>Configure Classifier</strong> - Initialize the classifier specified by
 * {@code classifierNid()} with the profile specified by {@code descriptionLogicProfileNid()}</li>
 *
 * <li><strong>Classify Concepts</strong> - Process concepts from the member pattern specified
 * by {@code conceptMemberPatternNid()}</li>
 *
 * <li><strong>Store Inferred Axioms</strong> - Write inferred axioms to the pattern specified
 * by {@code inferredAxiomsPatternNid()}</li>
 *
 * <li><strong>Generate Navigation</strong> - Build navigational digraphs according to
 * {@code statedNavigationPatternNid()} and {@code inferredNavigationPatternNid()}</li>
 * </ol>
 *
 * <h3>Description Logic Profiles</h3>
 *
 * <p>Common profiles and their characteristics:</p>
 *
 * <dl>
 * <dt><strong>EL++</strong></dt>
 * <dd>Subset of description logic supporting existential restrictions, conjunctions, and role
 * hierarchies. Polynomial-time classification. Widely used in medical terminologies like SNOMED CT.</dd>
 *
 * <dt><strong>ALC</strong></dt>
 * <dd>Attributive concept language with complements. Supports negation, disjunction, universal
 * restrictions. ExpTime-complete classification.</dd>
 *
 * <dt><strong>SROIQ</strong></dt>
 * <dd>Highly expressive profile underlying OWL 2 DL. Supports complex role constructors,
 * nominals, qualified cardinality restrictions. NExpTime-complete classification.</dd>
 * </dl>
 *
 * <h3>Subsumption and Equivalence</h3>
 *
 * <p>Logic coordinates enable subsumption testing through integration with navigation calculators:</p>
 *
 * <pre>{@code
 * ViewCalculator view = ViewCalculatorWithCache.getCalculator(viewCoord);
 *
 * // Test if conceptA subsumes conceptB (conceptA is ancestor of conceptB)
 * boolean subsumes = view.isDescendentOf(conceptB, conceptA);
 *
 * // Test logical definition presence
 * boolean isDefined = view.isDefined(conceptNid);
 *
 * // Get all ancestors (subsumers) via inferred navigation
 * IntIdSet ancestors = view.ancestorsOf(conceptNid);
 * }</pre>
 *
 * <h3>Integration with Navigation</h3>
 *
 * <p>Logic coordinates generate navigation patterns that feed into navigation coordinates:</p>
 * <ul>
 * <li>Stated navigation patterns provide author-asserted hierarchies</li>
 * <li>Inferred navigation patterns provide classifier-generated taxonomies</li>
 * <li>Navigation coordinates reference these patterns for graph construction</li>
 * <li>Navigation calculators traverse the resulting digraphs</li>
 * </ul>
 *
 * <h3>Thread Safety and Immutability</h3>
 *
 * <p>LogicCoordinateRecord instances are immutable and thread-safe, suitable for:</p>
 * <ul>
 * <li>Concurrent classification and reasoning operations</li>
 * <li>Caching in calculator implementations</li>
 * <li>Use as map keys for axiom caches</li>
 * <li>Sharing across service boundaries</li>
 * </ul>
 *
 * @see dev.ikm.tinkar.coordinate.logic.LogicCoordinate
 * @see dev.ikm.tinkar.coordinate.logic.LogicCoordinateRecord
 * @see dev.ikm.tinkar.coordinate.logic.LogicCoordinateDelegate
 * @see dev.ikm.tinkar.coordinate.logic.PremiseType
 * @see dev.ikm.tinkar.coordinate.logic.TaxonomyFlag
 * @see dev.ikm.tinkar.coordinate.logic.calculator
 * @see dev.ikm.tinkar.coordinate.Coordinates.Logic
 */
package dev.ikm.tinkar.coordinate.logic;
