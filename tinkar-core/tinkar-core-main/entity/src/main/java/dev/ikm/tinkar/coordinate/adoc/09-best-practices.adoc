= Best Practices

[NOTE]
====
This document describes the IKE Coordinate System (Integrated Knowledge Ecosystem), based on the HL7 TINKAR specification. Technical references use "Tinkar" in code for backward compatibility.
====

== Overview

This section provides guidance on effectively using coordinates in IKE applications. Following these practices will help you build robust, performant, and maintainable systems.

== Coordinate Creation and Management

=== Use Predefined Coordinates

[source,java]
----
// GOOD: Use factory methods
StampCoordinateRecord stamp = Coordinates.Stamp.DevelopmentLatestActiveOnly();
LanguageCoordinate lang = Coordinates.Language.UsEnglishRegularName();

// BAD: Manual construction when factory exists
StampCoordinateRecord stamp = StampCoordinateRecord.make(
    StateSet.ACTIVE_ONLY,
    StampPositionRecord.make(Long.MAX_VALUE, developmentPathNid)
);
----

**Why?** Predefined coordinates are tested, documented, and communicate intent clearly.

=== Create Reusable Coordinate Factories

[source,java]
----
// GOOD: Centralized coordinate definitions
public class AppCoordinates {
    public static ViewCoordinateRecord production() {
        return ViewCoordinateRecord.make(
            Coordinates.Stamp.DevelopmentLatestActiveOnly()
                .withPath(TinkarTerm.MASTER_PATH),
            Coordinates.Language.UsEnglishRegularName(),
            Coordinates.Logic.ElPlusPlus(),
            Coordinates.Navigation.inferred(),
            Coordinates.Edit.Default()
        );
    }

    public static ViewCoordinateRecord development(int authorNid) {
        return ViewCoordinateRecord.make(
            Coordinates.Stamp.DevelopmentLatestActiveOnly(),
            Coordinates.Language.UsEnglishRegularName(),
            Coordinates.Logic.ElPlusPlus(),
            Coordinates.Navigation.stated(),
            EditCoordinateRecord.make(
                authorNid,
                TinkarTerm.SOLOR_OVERLAY_MODULE.nid(),
                TinkarTerm.SOLOR_OVERLAY_MODULE.nid(),
                TinkarTerm.DEVELOPMENT_PATH.nid(),
                TinkarTerm.DEVELOPMENT_PATH.nid()
            )
        );
    }
}

// Usage
ViewCalculator prodCalc = ViewCalculatorWithCache.getCalculator(
    AppCoordinates.production()
);
----

**Why?** Centralization ensures consistency and simplifies maintenance.

=== Document Custom Coordinates

[source,java]
----
// GOOD: Clear documentation
/**
 * Creates a view coordinate for clinical content review.
 * <p>
 * Configuration:
 * - Shows both active and inactive content (for review)
 * - Latest versions on development path
 * - English descriptions with FSN fallback
 * - Inferred navigation for clinical hierarchy
 * - Read-only (no editing)
 *
 * @return view coordinate for clinical review
 */
public static ViewCoordinateRecord clinicalReview() {
    return ViewCoordinateRecord.make(
        StampCoordinateRecord.make(
            StateSet.ACTIVE_AND_INACTIVE,  // See inactive for review
            StampPositionRecord.make(
                Long.MAX_VALUE,
                TinkarTerm.DEVELOPMENT_PATH.nid()
            )
        ),
        // ... rest of configuration
    );
}
----

**Why?** Documents rationale for coordinate choices and expected behavior.

== Calculator Usage

=== Cache Calculators, Not Coordinates

[source,java]
----
// GOOD: Cache calculators
private final ViewCalculator calculator;

public MyService(ViewCoordinateRecord view) {
    this.calculator = ViewCalculatorWithCache.getCalculator(view);
}

public void process(List<Integer> conceptNids) {
    for (int nid : conceptNids) {
        String desc = calculator.getDescriptionText(nid);
        // Process...
    }
}

// BAD: Recreate calculator repeatedly
public void process(List<Integer> conceptNids) {
    for (int nid : conceptNids) {
        ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);
        String desc = calc.getDescriptionText(nid);
    }
}
----

**Why?** Calculator creation has overhead; caching improves performance significantly.

=== Use Appropriate Calculator Type

[source,java]
----
// GOOD: Use specific calculator when only one coordinate type needed
StampCalculator stampCalc = StampCalculatorWithCache.getCalculator(stampCoord);
Latest<ConceptVersion> latest = stampCalc.latest(conceptNid);

// AVOID: Using ViewCalculator when only STAMP operations needed
ViewCalculator viewCalc = ViewCalculatorWithCache.getCalculator(view);
Latest<ConceptVersion> latest = viewCalc.latest(conceptNid);
----

**Why?** Specific calculators have less overhead when you don't need full view functionality.

=== Don't Mix Calculator Contexts

[source,java]
----
// BAD: Using results from different contexts
StampCalculator stampCalc1 = StampCalculatorWithCache.getCalculator(stamp1);
LanguageCalculator langCalc2 = LanguageCalculatorWithCache.getCalculator(
    stamp2,  // Different STAMP!
    languageCoords
);

Latest<ConceptVersion> latest = stampCalc1.latest(conceptNid);
String description = langCalc2.getDescriptionText(conceptNid);
// Description may be for different version!

// GOOD: Consistent context
ViewCalculator viewCalc = ViewCalculatorWithCache.getCalculator(view);
Latest<ConceptVersion> latest = viewCalc.latest(conceptNid);
String description = viewCalc.getDescriptionText(conceptNid);
// Description matches version
----

**Why?** Mixing contexts leads to inconsistent, confusing results.

== STAMP Coordinates

=== Choose Appropriate State Filter

[source,java]
----
// Production/user-facing: Active only
StampCoordinateRecord userStamp = StampCoordinateRecord.make(
    StateSet.ACTIVE_ONLY,
    position
);

// Administrative/review: Include inactive
StampCoordinateRecord adminStamp = StampCoordinateRecord.make(
    StateSet.ACTIVE_AND_INACTIVE,
    position
);

// Specific state needs: Use StateSet methods
StateSet customStates = StateSet.ACTIVE_ONLY
    .withState(State.INACTIVE);
----

**Why?** State filtering prevents inappropriate content from reaching users.

=== Use Appropriate Time Position

[source,java]
----
// Latest versions
StampPositionRecord latest = StampPositionRecord.make(
    Long.MAX_VALUE,
    pathNid
);

// Point-in-time (release, audit, comparison)
StampPositionRecord release = StampPositionRecord.make(
    releaseTimestamp,
    pathNid
);

// Specific date range queries
long startTime = LocalDate.of(2024, 1, 1)
    .atStartOfDay(ZoneId.systemDefault())
    .toInstant()
    .toEpochMilli();
StampPositionRecord start = StampPositionRecord.make(startTime, pathNid);
----

**Why?** Time position controls which versions are visible.

=== Use Module Filtering Appropriately

[source,java]
----
// Include specific modules
StampCoordinateRecord filtered = stamp.withModuleNids(
    IntIds.set.of(module1Nid, module2Nid)
);

// Exclude specific modules
StampCoordinateRecord excluded = stamp.withExcludedModuleNids(
    IntIds.set.of(testModuleNid)
);

// Module priority (when versions conflict)
StampCoordinateRecord prioritized = stamp.withModulePriorityNidList(
    IntIds.list.of(
        extensionModuleNid,  // Prefer extension
        coreModuleNid        // Fall back to core
    )
);
----

**Why?** Module filtering enables modular terminology management.

== Language Coordinates

=== Provide Appropriate Fallback

[source,java]
----
// GOOD: Cascading fallback
List<LanguageCoordinate> languages = List.of(
    Coordinates.Language.SpanishLanguage(),  // Preferred
    Coordinates.Language.UsEnglishRegularName()  // Fallback
);

// AVOID: No fallback (may return empty)
List<LanguageCoordinate> languages = List.of(
    Coordinates.Language.SpanishLanguage()
);
----

**Why?** Fallback ensures descriptions are always available.

=== Order Description Types Appropriately

[source,java]
----
// Clinical display: Regular name first
LanguageCoordinate clinical = LanguageCoordinateRecord.make(
    TinkarTerm.ENGLISH_LANGUAGE.nid(),
    List.of(TinkarTerm.US_DIALECT_ASSEMBLAGE.nid()),
    List.of(
        TinkarTerm.REGULAR_NAME_DESCRIPTION_TYPE.nid(),
        TinkarTerm.FULLY_QUALIFIED_NAME_DESCRIPTION_TYPE.nid()
    )
);

// Technical/debugging: FSN first
LanguageCoordinate technical = LanguageCoordinateRecord.make(
    TinkarTerm.ENGLISH_LANGUAGE.nid(),
    List.of(TinkarTerm.US_DIALECT_ASSEMBLAGE.nid()),
    List.of(
        TinkarTerm.FULLY_QUALIFIED_NAME_DESCRIPTION_TYPE.nid(),
        TinkarTerm.REGULAR_NAME_DESCRIPTION_TYPE.nid()
    )
);
----

**Why?** Description type order affects which descriptions are selected.

=== Use Language-Agnostic for Identifiers

[source,java]
----
// GOOD: Language-agnostic for UUIDs, codes
LanguageCoordinate identifiers =
    Coordinates.Language.LanguageAgnostic();

// Use for code lookups
ViewCalculator calc = ViewCalculatorWithCache.getCalculator(
    view.withLanguageCoordinates(List.of(identifiers))
);
----

**Why?** Identifiers don't depend on language preferences.

== Logic Coordinates

=== Match Premise Type to Use Case

[source,java]
----
// Authoring/editing: Stated axioms
LogicCoordinate authoring = LogicCoordinateRecord.make(
    statedPatternNid,
    inferredPatternNid,
    classifierNid,
    TinkarTerm.STATED_PREMISE_TYPE.nid()  // What author created
);

// Querying/browsing: Inferred axioms
LogicCoordinate querying = LogicCoordinateRecord.make(
    statedPatternNid,
    inferredPatternNid,
    classifierNid,
    TinkarTerm.INFERRED_PREMISE_TYPE.nid()  // What classifier computed
);
----

**Why?** Stated shows authored content; inferred shows computed subsumption.

=== Understand Classifier Differences

[source,java]
----
// EL++: Fast, suitable for most clinical terminologies
LogicCoordinate elPlusPlus = Coordinates.Logic.ElPlusPlus();

// Full OWL: More expressive but slower
// Use only when EL++ is insufficient
----

**Why?** Classifier choice affects reasoning capabilities and performance.

== Navigation Coordinates

=== Match Navigation Pattern to Task

[source,java]
----
// Browsing: Inferred (shows computed hierarchy)
NavigationCoordinate browsing = Coordinates.Navigation.inferred();

// Authoring: Stated (shows authored hierarchy)
NavigationCoordinate authoring = Coordinates.Navigation.stated();

// Comparison: Both
NavigationCoordinate both = NavigationCoordinateRecord.make(
    IntIds.set.of(
        TinkarTerm.INFERRED_NAVIGATION.nid(),
        TinkarTerm.STATED_NAVIGATION.nid()
    ),
    StateSet.ACTIVE_ONLY,
    true,
    IntIds.list.empty()
);
----

**Why?** Navigation pattern affects which relationships are used.

=== Use Vertex State Filtering

[source,java]
----
// Production: Active vertices only
NavigationCoordinate production = NavigationCoordinateRecord.make(
    navigationPatternNids,
    StateSet.ACTIVE_ONLY,  // Only active in hierarchy
    true,
    IntIds.list.empty()
);

// Review: Include inactive
NavigationCoordinate review = NavigationCoordinateRecord.make(
    navigationPatternNids,
    StateSet.ACTIVE_AND_INACTIVE,  // See deprecated concepts
    true,
    IntIds.list.empty()
);
----

**Why?** Vertex state filtering controls hierarchy visibility.

=== Enable Sorting for User Display

[source,java]
----
// User-facing: Sorted
NavigationCoordinate userNav = NavigationCoordinateRecord.make(
    navigationPatternNids,
    StateSet.ACTIVE_ONLY,
    true,  // Sort for readability
    IntIds.list.empty()
);

// Programmatic: Unsorted (when order doesn't matter)
NavigationCoordinate progNav = NavigationCoordinateRecord.make(
    navigationPatternNids,
    StateSet.ACTIVE_ONLY,
    false,  // Don't sort (faster)
    IntIds.list.empty()
);
----

**Why?** Sorting improves UX but has performance cost.

== Edit Coordinates

=== Use Per-User Edit Coordinates

[source,java]
----
// GOOD: Each user has own edit coordinate
public EditCoordinateRecord getEditCoordinateForUser(User user) {
    return EditCoordinateRecord.make(
        user.getConceptNid(),     // Proper attribution
        user.getDefaultModule(),
        user.getDefaultModule(),
        TinkarTerm.DEVELOPMENT_PATH.nid(),
        TinkarTerm.DEVELOPMENT_PATH.nid()
    );
}

// BAD: Shared edit coordinate
public static final EditCoordinateRecord SHARED_EDIT =
    Coordinates.Edit.Default();
// Can't track who made changes!
----

**Why?** Per-user coordinates enable proper change attribution.

=== Match Default Module to Context

[source,java]
----
// Core development
EditCoordinateRecord coreEdit = EditCoordinateRecord.make(
    authorNid,
    TinkarTerm.CORE_MODULE.nid(),  // New content goes to core
    TinkarTerm.CORE_MODULE.nid(),
    TinkarTerm.DEVELOPMENT_PATH.nid(),
    TinkarTerm.DEVELOPMENT_PATH.nid()
);

// Extension development
EditCoordinateRecord extEdit = EditCoordinateRecord.make(
    authorNid,
    extensionModuleNid,  // New content goes to extension
    coreModuleNid,       // Can modularize to core
    TinkarTerm.DEVELOPMENT_PATH.nid(),
    TinkarTerm.MASTER_PATH.nid()
);
----

**Why?** Default module controls where new content is created.

=== Configure Paths for Workflow

[source,java]
----
// Development workflow
EditCoordinateRecord devEdit = EditCoordinateRecord.make(
    authorNid,
    moduleNid,
    moduleNid,
    TinkarTerm.DEVELOPMENT_PATH.nid(),  // Create on dev
    TinkarTerm.DEVELOPMENT_PATH.nid()   // No promotion
);

// Release workflow
EditCoordinateRecord releaseEdit = EditCoordinateRecord.make(
    authorNid,
    moduleNid,
    moduleNid,
    TinkarTerm.DEVELOPMENT_PATH.nid(),  // Create on dev
    TinkarTerm.MASTER_PATH.nid()        // Promote to master
);
----

**Why?** Path configuration supports development workflows.

== View Coordinates

=== Use View Coordinates for Consistency

[source,java]
----
// GOOD: Single view for all operations
ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);

String description = calc.getDescriptionText(conceptNid);
int[] parents = calc.unsortedParentsOf(conceptNid);
Latest<ConceptVersion> latest = calc.latest(conceptNid);
// All operations use consistent context

// AVOID: Mixing different coordinate types
StampCalculator stampCalc = StampCalculatorWithCache.getCalculator(stamp1);
LanguageCalculator langCalc = LanguageCalculatorWithCache.getCalculator(
    stamp2,
    languageCoords
);
// May have inconsistent results
----

**Why?** View coordinates ensure consistency across all operations.

=== Create Views for Specific Use Cases

[source,java]
----
public class Views {
    public static ViewCoordinateRecord forDevelopment() {
        // Development configuration
    }

    public static ViewCoordinateRecord forProduction() {
        // Production configuration
    }

    public static ViewCoordinateRecord forAudit() {
        // Audit configuration
    }

    public static ViewCoordinateRecord forUser(User user) {
        // User-specific configuration
    }
}
----

**Why?** Named views communicate intent and ensure correct configuration.

== Performance

=== Reuse Calculators

[source,java]
----
// GOOD: Reuse calculator instance
ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);

for (int conceptNid : conceptNids) {
    process(conceptNid, calc);
}

// BAD: Recreate calculator
for (int conceptNid : conceptNids) {
    ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);
    process(conceptNid, calc);
}
----

**Why?** Calculator creation and cache initialization have overhead.

=== Use Batch Operations

[source,java]
----
// GOOD: Process in batch with single calculator
public void processConceptsBatch(IntIdSet conceptNids, ViewCalculator calc) {
    conceptNids.forEach(nid -> {
        String desc = calc.getDescriptionText(nid);
        int[] parents = calc.unsortedParentsOf(nid);
        process(desc, parents);
    });
}

// AVOID: Creating new calculator for each concept
public void processConcepts(IntIdSet conceptNids) {
    conceptNids.forEach(nid -> {
        ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);
        String desc = calc.getDescriptionText(nid);
    });
}
----

**Why?** Batch operations amortize calculator overhead.

=== Leverage Built-in Caching

[source,java]
----
// Calculators with caching
ViewCalculator viewCalc = ViewCalculatorWithCache.getCalculator(view);
StampCalculator stampCalc = StampCalculatorWithCache.getCalculator(stamp);
LanguageCalculator langCalc = LanguageCalculatorWithCache.getCalculator(
    stamp,
    languageCoords
);

// Cache handles repeated queries efficiently
String desc1 = viewCalc.getDescriptionText(conceptNid);
String desc2 = viewCalc.getDescriptionText(conceptNid);  // Cached!
----

**Why?** Built-in caching dramatically improves repeated query performance.

== Thread Safety

=== Coordinates Are Immutable and Thread-Safe

[source,java]
----
// GOOD: Share coordinates across threads
private final ViewCoordinateRecord view = Coordinates.View.DefaultView();

public void processInParallel(List<Integer> conceptNids) {
    conceptNids.parallelStream().forEach(nid -> {
        ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);
        process(nid, calc);
    });
}
----

**Why?** Immutable coordinates can be safely shared between threads.

=== Calculators Are Thread-Safe

[source,java]
----
// GOOD: Share calculator across threads
private final ViewCalculator calculator =
    ViewCalculatorWithCache.getCalculator(view);

public void processInParallel(List<Integer> conceptNids) {
    conceptNids.parallelStream().forEach(nid -> {
        String desc = calculator.getDescriptionText(nid);
        process(nid, desc);
    });
}
----

**Why?** Calculators are thread-safe and can be shared.

== Testing

=== Create Test-Specific Coordinates

[source,java]
----
public class TestCoordinates {
    public static ViewCoordinateRecord allStatesAllModules() {
        return ViewCoordinateRecord.make(
            StampCoordinateRecord.make(
                StateSet.ACTIVE_AND_INACTIVE,
                StampPositionRecord.make(
                    Long.MAX_VALUE,
                    TinkarTerm.DEVELOPMENT_PATH.nid()
                )
            ),
            Coordinates.Language.UsEnglishRegularName(),
            Coordinates.Logic.ElPlusPlus(),
            Coordinates.Navigation.inferred(),
            Coordinates.Edit.Default()
        );
    }
}

@Test
void testInactiveConceptHandling() {
    ViewCalculator calc = ViewCalculatorWithCache.getCalculator(
        TestCoordinates.allStatesAllModules()
    );
    // Test can see inactive concepts
}
----

**Why?** Test-specific coordinates enable comprehensive testing.

=== Test with Multiple Coordinate Configurations

[source,java]
----
@ParameterizedTest
@MethodSource("coordinateProvider")
void testWithDifferentCoordinates(ViewCoordinateRecord view) {
    ViewCalculator calc = ViewCalculatorWithCache.getCalculator(view);
    // Test behavior with different coordinate configurations
}

static Stream<ViewCoordinateRecord> coordinateProvider() {
    return Stream.of(
        Coordinates.View.DefaultView(),
        TestCoordinates.allStatesAllModules(),
        createProductionView()
    );
}
----

**Why?** Testing with multiple configurations catches coordinate-specific issues.

== Summary

Key best practices:

* **Creation**: Use predefined coordinates; create reusable factories
* **Calculators**: Cache and reuse; don't mix contexts
* **STAMP**: Choose appropriate state, time, and module filters
* **Language**: Provide fallback; order types appropriately
* **Logic**: Match premise type to use case
* **Navigation**: Match pattern to task; use appropriate sorting
* **Edit**: Per-user coordinates; match module to context
* **View**: Use for consistency; create named views
* **Performance**: Reuse calculators; use batch operations; leverage caching
* **Thread Safety**: Share immutable coordinates and thread-safe calculators
* **Testing**: Create test-specific coordinates; test multiple configurations

Following these practices will help you build robust, performant Tinkar applications.
